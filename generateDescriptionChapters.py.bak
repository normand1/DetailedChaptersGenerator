from dotenv import load_dotenv
import json, os, re
import anthropic
from datetime import datetime

load_dotenv()

client = anthropic.Anthropic()


def extract_number(filename):
    match = re.search(r"\d+", filename)
    return int(match.group()) if match else 0


def find_files_with_specific_guid(directory, number):
    for root, dirs, files in os.walk(directory):
        for file in files:
            if str(number) in file:
                return file


def convert_time_str_to_seconds(time_str):
    time_format = "%H:%M:%S"
    time_object = datetime.strptime(time_str, time_format)
    total_seconds = (
        time_object.hour * 3600 + time_object.minute * 60 + time_object.second
    )
    return int(total_seconds)


links_dir = "latentspacepodcast/links/"
linkFiles = os.listdir(links_dir)

for linkFile in linkFiles:
    with open(links_dir + linkFile, "r", encoding="utf-8") as f:
        links = json.load(f)

    number = extract_number(links_dir + linkFile)

    srt_file = find_files_with_specific_guid("latentspacepodcast/srt/", number)
    chaps_file = find_files_with_specific_guid("latentspacepodcast/chapters/", number)

    if not os.path.exists(
        "latentspacepodcast/srt/" + (srt_file or "null")
    ) or not os.path.exists("latentspacepodcast/chapters/" + (chaps_file or "null")):
        continue

    with open("latentspacepodcast/srt/" + srt_file, "r", encoding="utf-8") as f:
        transcript = f.read().strip()

    links_str = "\n".join([f"{link}: {url}" for link, url in links.items()])

    prompt = f"""You will be given an SRT transcript of a podcast and a list of links discussed during the podcast. Your task is to create a mapping between each link and the timestamp when it was discussed in the podcast.

Here is the SRT transcript of the podcast:
<transcript>
{transcript}
</transcript>

Here are the links discussed during the podcast:
<links>
{links_str}
</links>

Follow these steps to complete the task:

1. Parse the SRT transcript, paying attention to the timestamps and the content of each subtitle.

2. For each link in the provided list, search for mentions or discussions of that link in the transcript. Look for exact matches, partial matches, or contextual clues that indicate the link is being discussed.

3. When you find a mention of a link, note the timestamp associated with that part of the transcript.

4. Create a mapping between each link and the earliest timestamp when it was mentioned or discussed.

5. If a link is not mentioned in the transcript, map it to "Not mentioned".

Provide your output in the following format:
<link_timestamp_mapping>
[Link 1]: [Timestamp]
[Link 2]: [Timestamp]
...
</link_timestamp_mapping>

Make sure to include all links from the provided list in your mapping, even if they were not mentioned in the transcript.

Note: Timestamps should be in the format used in the SRT transcript (typically HH:MM:SS,mmm)."""

    response = client.completions.create(
        model="claude-3-5-sonnet-20240620",
        prompt=prompt,
        max_tokens_to_sample=2000,
        temperature=0,
    )

    result = response.completion

    # Extract the link_timestamp_mapping
    pattern = r"<link_timestamp_mapping>(.*?)</link_timestamp_mapping>"
    match = re.search(pattern, result, re.DOTALL)

    if match:
        mapping_str = match.group(1).strip()
        mapping_lines = mapping_str.split("\n")

        with open("latentspacepodcast/chapters/" + chaps_file, "r") as f:
            data = json.load(f)

        for line in mapping_lines:
            link, timestamp = line.split("]: ")
            link = link[1:]  # Remove the leading '['
            timestamp = timestamp.strip()

            if timestamp != "Not mentioned":
                chapter = {
                    "startTime": convert_time_str_to_seconds(timestamp.split(",")[0]),
                    "url": links[link],
                    "title": link,
                }
                data["chapters"].append(chapter)

        with open("latentspacepodcast/chapters/" + chaps_file, "w") as f:
            json.dump(data, f)
    else:
        print(f"No valid mapping found for file: {linkFile}")
